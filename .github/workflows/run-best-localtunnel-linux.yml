name: BEST Headless Server with LocalTunnel + Cloudflare WARP (Linux)

# This workflow uses Cloudflare WARP to route traffic through Cloudflare's network
# WARP is fast, reliable, and free - much better than free VPNs
# Note: WARP routes through nearest Cloudflare datacenter, not specifically Russia

on:
  workflow_dispatch:
    inputs:
      subdomain:
        description: 'Custom subdomain (e.g., bharanitest007 for https://bharanitest007.loca.lt)'
        required: true
        type: string
      rc1:
        description: 'Recovery Code 1'
        required: false
        type: string
      rc2:
        description: 'Recovery Code 2'
        required: false
        type: string
      rc3:
        description: 'Recovery Code 3'
        required: false
        type: string
      rc4:
        description: 'Recovery Code 4'
        required: false
        type: string
      kickrc:
        description: 'Kick Code'
        required: false
        type: string
      planet:
        description: 'Planet Name'
        required: false
        type: string
      device:
        description: 'Device Type (312=Android, 323=iOS, 352=Web)'
        required: false
        default: '312'
        type: string
      duration:
        description: 'Run duration in minutes (max 60 = 1 hour)'
        required: false
        default: '60'
        type: string

jobs:
  deploy-backend-warp:
    name: üöÄ Deploy with WARP for ${{ github.event.inputs.subdomain }}
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: resources/app/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('resources/app/package.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Cloudflare WARP (via WireGuard)
        run: |
          echo "=========================================="
          echo "üîí Installing Cloudflare WARP via WireGuard"
          echo "=========================================="
          
          # Install WireGuard
          sudo apt-get update -qq
          sudo apt-get install -y wireguard-tools curl jq
          
          # Download wgcf (unofficial WARP client that works non-interactively)
          echo "Downloading wgcf..."
          
          # Get latest release URL
          WGCF_URL=$(curl -s https://api.github.com/repos/ViRb3/wgcf/releases/latest | jq -r '.assets[] | select(.name | contains("linux_amd64")) | .browser_download_url')
          
          if [ -z "$WGCF_URL" ]; then
            echo "‚ö†Ô∏è  Failed to get latest wgcf URL, using fallback..."
            WGCF_URL="https://github.com/ViRb3/wgcf/releases/download/v2.2.22/wgcf_2.2.22_linux_amd64"
          fi
          
          echo "Downloading from: $WGCF_URL"
          
          if ! curl -fsSL "$WGCF_URL" -o wgcf; then
            echo "‚ùå Failed to download wgcf"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          chmod +x wgcf
          sudo mv wgcf /usr/local/bin/
          
          # Verify installation
          if ! command -v wgcf &> /dev/null; then
            echo "‚ùå wgcf installation failed"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          wgcf_version=$(wgcf version 2>/dev/null || echo "2.2.22")
          echo "‚úÖ wgcf installed: $wgcf_version"
          echo "‚úÖ WireGuard tools installed"
          echo "=========================================="

      - name: Register with Cloudflare WARP (Don't start yet)
        run: |
          echo "=========================================="
          echo "üîí Registering with Cloudflare WARP"
          echo "=========================================="
          
          # Check if wgcf is installed
          if ! command -v wgcf &> /dev/null; then
            echo "‚ö†Ô∏è  wgcf not installed, skipping..."
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # Register with WARP (non-interactive, no ToS prompt)
          echo "Registering with WARP..."
          if ! wgcf register --accept-tos; then
            echo "‚ùå WARP registration failed"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ WARP registered"
          
          # Generate WireGuard configuration
          echo "Generating WireGuard config..."
          if ! wgcf generate; then
            echo "‚ùå Failed to generate WireGuard config"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ WireGuard config generated"
          
          # Move config to WireGuard directory
          sudo mv wgcf-profile.conf /etc/wireguard/warp.conf
          
          echo "‚úÖ WARP ready (will start after LocalTunnel)"
          echo "=========================================="
            echo ""
            
            echo "WARP_CONNECTED=true" >> $GITHUB_ENV
            echo "WARP_IP=$external_ip" >> $GITHUB_ENV
            echo "WARP_LOCATION=$city, $country" >> $GITHUB_ENV
          else
            echo "‚úÖ WARP connected (IP check failed)"
            echo "WARP_CONNECTED=true" >> $GITHUB_ENV
          fi

      - name: Install system dependencies
        run: |
          echo "Installing system dependencies..."
          sudo apt-get install -y --no-install-recommends \
            curl \
            jq \
            libnss3 \
            libatk1.0-0 \
            libatk-bridge2.0-0 \
            libcups2 \
            libdrm2 \
            libxkbcommon0 \
            libxcomposite1 \
            libxdamage1 \
            libxfixes3 \
            libxrandr2 \
            libgbm1 \
            libpango-1.0-0 \
            libcairo2 \
            libatspi2.0-0 \
            xvfb \
            libasound2 || true
          
          echo "‚úÖ System dependencies installed"

      - name: Install application dependencies
        run: |
          cd resources/app
          npm install --prefer-offline --no-audit
          echo "‚úÖ Application dependencies installed"

      - name: Install localtunnel
        run: |
          npm install -g localtunnel --no-audit --silent
          echo "‚úÖ localtunnel installed globally"

      - name: Start BEST in Headless Mode
        env:
          HEADLESS: 'true'
          API_PORT: '3000'
          DISPLAY: ':99'
          TUNNEL_SUBDOMAIN: '${{ github.event.inputs.subdomain }}'
        run: |
          echo "Starting virtual display (Xvfb)..."
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          sleep 1
          echo "‚úÖ Virtual display started"

          echo "Starting BEST in headless mode..."
          cd resources/app

          # Verify files exist
          if [ ! -f "package.json" ] || [ ! -d "node_modules" ] || [ ! -f "main.js" ]; then
            echo "‚ùå Required files not found!"
            exit 1
          fi

          echo "‚úÖ All required files present"

          # Start BEST in background
          echo "üöÄ Starting BEST with HEADLESS=true"
          nohup npm run headless > ../../best-server.log 2>&1 &
          BEST_PID=$!
          echo "‚úÖ BEST started with PID: $BEST_PID"

          # Wait for server to start
          echo "Waiting for API server to start..."
          sleep 3

          # Verify server is running
          attempts=0
          max_attempts=6
          server_started=false
          wait_time=2

          while [ $attempts -lt $max_attempts ] && [ "$server_started" = "false" ]; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts/$max_attempts to connect to API server..."

            if curl -s --max-time 3 http://localhost:3000/api/health > /dev/null 2>&1; then
              health_response=$(curl -s http://localhost:3000/api/health)
              echo "‚úÖ BEST API Server is running!"
              echo "Response: $health_response"
              server_started=true
            else
              echo "‚ö†Ô∏è  Attempt $attempts failed"
              if [ $attempts -lt $max_attempts ]; then
                echo "Waiting $wait_time seconds before retry..."
                sleep $wait_time
                wait_time=$((wait_time * 2))
              fi
            fi
          done

          if [ "$server_started" = "false" ]; then
            echo "‚ùå Failed to start BEST API Server"
            echo ""
            echo "Server logs:"
            tail -n 100 ../../best-server.log || echo "No logs"
            exit 1
          fi

          echo "BEST_PID=$BEST_PID" >> $GITHUB_ENV

      - name: Start LocalTunnel (BEFORE WARP)
        run: |
          echo "Starting localtunnel..."
          subdomain="${{ github.event.inputs.subdomain }}"

          if [ -n "$subdomain" ]; then
            echo "Using custom subdomain: $subdomain"
            tunnel_url="https://$subdomain.loca.lt"

            # Start localtunnel in background BEFORE WARP
            # This ensures LocalTunnel establishes connection before WARP routing starts
            nohup lt --port 3000 --subdomain "$subdomain" > localtunnel.log 2>&1 &
            LT_PID=$!
            echo "LocalTunnel started with PID: $LT_PID"
          else
            echo "‚ùå Subdomain is required!"
            exit 1
          fi

          echo "Waiting for tunnel to establish..."
          sleep 5

          # Verify tunnel
          attempts=0
          max_attempts=10
          tunnel_established=false

          while [ $attempts -lt $max_attempts ] && [ "$tunnel_established" = "false" ]; do
            attempts=$((attempts + 1))

            if grep -q "your url is:" localtunnel.log 2>/dev/null; then
              echo "‚úÖ LocalTunnel tunnel established!"
              tunnel_established=true
            else
              if [ $attempts -lt $max_attempts ]; then
                echo "Waiting for tunnel... (attempt $attempts/$max_attempts)"
                sleep 2
              fi
            fi
          done

          if [ "$tunnel_established" = "false" ]; then
            echo "‚ö†Ô∏è  LocalTunnel may not be fully established yet"
            echo "Continuing anyway..."
          fi

          echo "LT_PID=$LT_PID" >> $GITHUB_ENV
          echo "TUNNEL_URL=$tunnel_url" >> $GITHUB_ENV

      - name: Connect to Cloudflare WARP (AFTER LocalTunnel)
        run: |
          echo ""
          echo "=========================================="
          echo "ÔøΩ Connecting tro Cloudflare WARP"
          echo "=========================================="
          echo ""
          echo "‚ÑπÔ∏è  LocalTunnel is already running"
          echo "   WARP will now route application traffic"
          echo ""
          
          # Check if wgcf is installed
          if ! command -v wgcf &> /dev/null; then
            echo "‚ö†Ô∏è  wgcf not installed, skipping WARP..."
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # Start WireGuard connection
          echo "Starting WARP connection..."
          if ! sudo wg-quick up warp; then
            echo "‚ùå Failed to start WARP"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ WARP connected!"
          
          # Wait for connection to stabilize
          sleep 3
          
          # Verify connection
          echo ""
          echo "Verifying WARP connection..."
          
          # Check WireGuard interface
          if ! ip addr show warp &> /dev/null; then
            echo "‚ùå WARP interface not found"
            echo "WARP_CONNECTED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ WARP interface active"
          
          # Get external IP
          echo ""
          echo "Checking external IP..."
          sleep 2
          external_ip=$(curl -s --max-time 10 https://api.ipify.org 2>/dev/null || echo "Unknown")
          
          if [ "$external_ip" != "Unknown" ]; then
            ip_info=$(curl -s --max-time 10 "https://ipapi.co/$external_ip/json/" 2>/dev/null || echo "{}")
            country=$(echo "$ip_info" | jq -r '.country_name // "Unknown"' 2>/dev/null || echo "Unknown")
            city=$(echo "$ip_info" | jq -r '.city // "Unknown"' 2>/dev/null || echo "Unknown")
            org=$(echo "$ip_info" | jq -r '.org // "Unknown"' 2>/dev/null || echo "Unknown")
            
            echo ""
            echo "=========================================="
            echo "‚úÖ WARP Connection Established!"
            echo "=========================================="
            echo ""
            echo "External IP: $external_ip"
            echo "Location: $city, $country"
            echo "Network: $org"
            echo ""
            echo "Application traffic routes through WARP"
            echo "LocalTunnel connection preserved"
            echo "=========================================="
            echo ""
            
            echo "WARP_CONNECTED=true" >> $GITHUB_ENV
            echo "WARP_IP=$external_ip" >> $GITHUB_ENV
            echo "WARP_LOCATION=$city, $country" >> $GITHUB_ENV
          else
            echo "‚úÖ WARP connected (IP check failed)"
            echo "WARP_CONNECTED=true" >> $GITHUB_ENV
          fi

      - name: Display Connection Status
        run: |
          tunnel_url="${TUNNEL_URL}"
          subdomain="${{ github.event.inputs.subdomain }}"
          
          echo ""
          echo "=========================================="
          echo "‚úÖ All Services Running!"
          echo "=========================================="
          echo ""
          echo "üåê Your BEST Backend URL:"
          echo ""
          echo "    $tunnel_url"
          echo ""
          
          if [ "${{ env.WARP_CONNECTED }}" = "true" ]; then
            echo "üîí WARP Status: CONNECTED"
            echo "üìç Routing through: Cloudflare Network"
            if [ -n "${{ env.WARP_LOCATION }}" ]; then
              echo "üåê Exit Location: ${{ env.WARP_LOCATION }}"
            fi
            echo ""
            echo "‚úÖ Game server connections route through WARP"
            echo "‚úÖ LocalTunnel connection working normally"
          else
            echo "‚ö†Ô∏è  WARP Status: NOT CONNECTED"
            echo "   (Using direct connection)"
          fi
          
          echo ""
          echo "=========================================="

      - name: Configure BEST via API
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        run: |
          echo "Configuring BEST..."
          
          config_json=$(cat <<EOF
          {
            "rc1": "${{ github.event.inputs.rc1 }}",
            "rc2": "${{ github.event.inputs.rc2 }}",
            "rc3": "${{ github.event.inputs.rc3 }}",
            "rc4": "${{ github.event.inputs.rc4 }}",
            "kickrc": "${{ github.event.inputs.kickrc }}",
            "planet": "${{ github.event.inputs.planet }}",
            "device": "${{ github.event.inputs.device }}"
          }
          EOF
          )
          
          if curl -X POST http://localhost:3000/api/configure \
            -H "Content-Type: application/json" \
            -d "$config_json" > /dev/null 2>&1; then
            echo "‚úÖ Configuration applied"
          else
            echo "‚ö†Ô∏è  Configuration failed"
          fi

      - name: Connect to Game
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        run: |
          echo "Connecting to game server..."
          
          if curl -X POST http://localhost:3000/api/connect \
            -H "Content-Type: application/json" > /dev/null 2>&1; then
            echo "‚úÖ Connection initiated"
            sleep 3
            echo "‚úÖ Connection status verified"
          else
            echo "‚ö†Ô∏è  Connection failed"
          fi

      - name: Display API Information
        run: |
          tunnel_url="${TUNNEL_URL}"
          subdomain="${{ github.event.inputs.subdomain }}"
          
          echo ""
          echo "=========================================="
          echo "üìö API Endpoints"
          echo "=========================================="
          echo ""
          echo "Base URL: $tunnel_url"
          echo ""
          echo "Available endpoints:"
          echo "  GET  $tunnel_url/api/health"
          echo "  GET  $tunnel_url/api/status"
          echo "  GET  $tunnel_url/api/logs"
          echo "  POST $tunnel_url/api/configure"
          echo "  POST $tunnel_url/api/connect"
          echo "  POST $tunnel_url/api/disconnect"
          echo "  POST $tunnel_url/api/send"
          echo ""
          echo "=========================================="

      - name: Keep Running with WARP Monitoring
        run: |
          duration="${{ github.event.inputs.duration }}"
          
          # Validate duration
          if [ -z "$duration" ] || [ "$duration" -lt 1 ]; then
            duration=60
          fi
          
          if [ "$duration" -gt 60 ]; then
            duration=60
          fi
          
          subdomain="${{ github.event.inputs.subdomain }}"
          tunnel_url="${TUNNEL_URL}"
          
          echo ""
          echo "=========================================="
          echo "üöÄ Backend Running with WARP for $subdomain"
          echo "=========================================="
          echo ""
          echo "Tunnel URL: $tunnel_url"
          echo "Duration: $duration minutes"
          echo "Started: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "Will stop: $(date -d "+$duration minutes" '+%Y-%m-%d %H:%M:%S')"
          
          if [ "${{ env.WARP_CONNECTED }}" = "true" ]; then
            echo "WARP: Connected (Cloudflare Network)"
          else
            echo "WARP: Not connected"
          fi
          
          echo ""
          echo "Monitoring status every 60 seconds..."
          echo ""
          
          end_time=$((SECONDS + duration * 60))
          check_count=0
          
          while [ $SECONDS -lt $end_time ]; do
            check_count=$((check_count + 1))
            
            # Check WARP status
            warp_status="N/A"
            if [ "${{ env.WARP_CONNECTED }}" = "true" ]; then
              if ip addr show warp &> /dev/null; then
                warp_status="‚úÖ Connected"
              else
                warp_status="‚ùå Disconnected"
                echo ""
                echo "‚ö†Ô∏è  WARNING: WARP connection lost!"
                echo "   Attempting to reconnect..."
                sudo wg-quick up warp 2>/dev/null || true
                echo ""
              fi
            fi
            
            # Check server status
            if status_response=$(curl -s --max-time 5 http://localhost:3000/api/status 2>/dev/null); then
              connected=$(echo "$status_response" | grep -o '"connected":[^,}]*' | cut -d':' -f2)
              remaining=$(( (end_time - SECONDS) / 60 ))
              
              if [ "$connected" = "true" ]; then
                status_icon="‚úÖ Connected"
              else
                status_icon="‚≠ï Ready"
              fi
              
              echo "[$(date '+%H:%M:%S')] Check #$check_count | $status_icon | WARP: $warp_status | Time left: $remaining min"
              
              if [ $((check_count % 10)) -eq 0 ]; then
                echo ""
                echo "üìå Tunnel: $tunnel_url"
                echo ""
              fi
            else
              echo "[$(date '+%H:%M:%S')] ‚ö†Ô∏è  Server status check failed"
            fi
            
            sleep 60
          done
          
          echo ""
          echo "=========================================="
          echo "‚è∞ Run duration completed ($duration minutes)"
          echo "=========================================="

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          
          # Disconnect from game
          curl -X POST http://localhost:3000/api/disconnect \
            -H "Content-Type: application/json" > /dev/null 2>&1 || true
          
          # Disconnect WARP
          if [ "${{ env.WARP_CONNECTED }}" = "true" ]; then
            echo "Disconnecting WARP..."
            sudo wg-quick down warp 2>/dev/null || true
            sleep 1
            echo "‚úÖ WARP disconnected"
          fi
          
          # Show final logs
          echo ""
          echo "Final server logs:"
          if [ -f "best-server.log" ]; then
            tail -n 50 best-server.log
          fi
          
          echo ""
          echo "‚úÖ Cleanup complete"
