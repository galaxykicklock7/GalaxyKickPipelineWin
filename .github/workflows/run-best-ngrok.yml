name: BEST Headless Server with ngrok Tunnel

on:
  workflow_dispatch:
    inputs:
      subdomain:
        description: 'Custom subdomain (e.g., best-backend-xyz for best-backend-xyz.ngrok-free.app)'
        required: false
        type: string
      rc1:
        description: 'Recovery Code 1'
        required: false
        type: string
      rc2:
        description: 'Recovery Code 2'
        required: false
        type: string
      rc3:
        description: 'Recovery Code 3'
        required: false
        type: string
      rc4:
        description: 'Recovery Code 4'
        required: false
        type: string
      kickrc:
        description: 'Kick Code'
        required: false
        type: string
      planet:
        description: 'Planet Name'
        required: false
        type: string
      device:
        description: 'Device Type (312=Android, 323=iOS, 352=Web)'
        required: false
        default: '312'
        type: string
      duration:
        description: 'Run duration in minutes (max 360 = 6 hours)'
        required: false
        default: '60'
        type: string

jobs:
  run-best-headless:
    runs-on: windows-latest
    timeout-minutes: 360  # Maximum 6 hours
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'

      - name: Install dependencies
        shell: pwsh
        run: |
          cd resources/app
          npm install
          Write-Host "Dependencies installed successfully"

      - name: Setup ngrok
        shell: pwsh
        run: |
          Write-Host "Downloading ngrok..."
          Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile "ngrok.zip"
          Expand-Archive -Path "ngrok.zip" -DestinationPath "." -Force
          Write-Host "ngrok downloaded successfully"

      - name: Configure ngrok
        shell: pwsh
        env:
          NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }}
        run: |
          if ($env:NGROK_AUTHTOKEN) {
            Write-Host "Configuring ngrok with authtoken..."
            .\ngrok.exe config add-authtoken $env:NGROK_AUTHTOKEN
            Write-Host "ngrok configured successfully"
          } else {
            Write-Host "‚ö†Ô∏è WARNING: NGROK_AUTHTOKEN secret not set!"
            Write-Host "Please add NGROK_AUTHTOKEN to repository secrets"
            Write-Host "Get your token from: https://dashboard.ngrok.com/get-started/your-authtoken"
            exit 1
          }

      - name: Start BEST in Headless Mode
        shell: pwsh
        env:
          HEADLESS: 'true'
          API_PORT: '3000'
        run: |
          Write-Host "Starting BEST in headless mode..."
          cd resources/app
          Start-Process -NoNewWindow -FilePath "npm" -ArgumentList "run", "headless-win"
          Write-Host "Waiting for API server to start..."
          Start-Sleep -Seconds 10
          
          # Verify server is running
          try {
            $health = Invoke-RestMethod -Uri "http://localhost:3000/api/health" -ErrorAction Stop
            Write-Host "‚úÖ BEST API Server is running!"
            Write-Host "Mode: $($health.mode)"
          } catch {
            Write-Host "‚ùå Failed to start BEST API Server"
            exit 1
          }

      - name: Start ngrok Tunnel
        shell: pwsh
        run: |
          Write-Host "Starting ngrok tunnel..."
          
          $subdomain = "${{ github.event.inputs.subdomain }}"
          
          if ($subdomain) {
            Write-Host "Using custom subdomain: $subdomain"
            Start-Process -NoNewWindow -FilePath ".\ngrok.exe" -ArgumentList "http", "3000", "--subdomain=$subdomain", "--log=stdout"
          } else {
            Write-Host "Using random subdomain (no custom subdomain provided)"
            Start-Process -NoNewWindow -FilePath ".\ngrok.exe" -ArgumentList "http", "3000", "--log=stdout"
          }
          
          Write-Host "Waiting for ngrok tunnel to establish..."
          Start-Sleep -Seconds 5
          
          # Get tunnel URL from ngrok API
          $maxAttempts = 10
          $attempt = 0
          $tunnelUrl = $null
          
          while ($attempt -lt $maxAttempts -and !$tunnelUrl) {
            try {
              $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -ErrorAction Stop
              if ($response.tunnels -and $response.tunnels.Count -gt 0) {
                $tunnelUrl = $response.tunnels[0].public_url
                Write-Host "`n=========================================="
                Write-Host "‚úÖ ngrok Tunnel Established!"
                Write-Host "=========================================="
                Write-Host ""
                Write-Host "üåê Your BEST Backend is now accessible at:"
                Write-Host ""
                Write-Host "    $tunnelUrl"
                Write-Host ""
                Write-Host "=========================================="
                Write-Host ""
                Write-Host "üìã Share this URL with your users!"
                Write-Host ""
                
                if ($subdomain) {
                  Write-Host "‚ú® Custom subdomain active: $subdomain"
                  Write-Host "This URL will remain the same on future runs!"
                } else {
                  Write-Host "‚ö†Ô∏è  This is a random URL and will change on next run"
                  Write-Host "üí° Tip: Reserve a custom subdomain for a permanent URL!"
                }
                
                Write-Host ""
                Write-Host "=========================================="
                break
              }
            } catch {
              $attempt++
              Write-Host "Waiting for ngrok... (attempt $attempt/$maxAttempts)"
              Start-Sleep -Seconds 2
            }
          }
          
          if (!$tunnelUrl) {
            Write-Host "‚ùå Failed to get tunnel URL from ngrok"
            Write-Host "Check ngrok logs above for errors"
            exit 1
          }

      - name: Configure BEST via API
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        shell: pwsh
        run: |
          Write-Host "Configuring BEST..."
          
          $config = @{
            rc1 = "${{ github.event.inputs.rc1 }}"
            rc2 = "${{ github.event.inputs.rc2 }}"
            rc3 = "${{ github.event.inputs.rc3 }}"
            rc4 = "${{ github.event.inputs.rc4 }}"
            kickrc = "${{ github.event.inputs.kickrc }}"
            planet = "${{ github.event.inputs.planet }}"
            device = "${{ github.event.inputs.device }}"
          }
          
          $jsonConfig = $config | ConvertTo-Json
          
          Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/configure" -Body $jsonConfig -ContentType "application/json"
          Write-Host "‚úÖ Configuration applied"

      - name: Connect to Game
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        shell: pwsh
        run: |
          Write-Host "Connecting to game server..."
          Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/connect" -ContentType "application/json"
          Write-Host "‚úÖ Connection initiated"

      - name: Display API Information
        shell: pwsh
        run: |
          # Get tunnel URL again
          try {
            $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -ErrorAction Stop
            $tunnelUrl = $response.tunnels[0].public_url
            
            Write-Host "`n=========================================="
            Write-Host "üìö API Endpoints"
            Write-Host "=========================================="
            Write-Host ""
            Write-Host "Base URL: $tunnelUrl"
            Write-Host ""
            Write-Host "Available endpoints:"
            Write-Host "  GET  $tunnelUrl/api/health"
            Write-Host "  GET  $tunnelUrl/api/status"
            Write-Host "  GET  $tunnelUrl/api/logs"
            Write-Host "  POST $tunnelUrl/api/configure"
            Write-Host "  POST $tunnelUrl/api/connect"
            Write-Host "  POST $tunnelUrl/api/disconnect"
            Write-Host "  POST $tunnelUrl/api/send"
            Write-Host ""
            Write-Host "=========================================="
            Write-Host ""
            Write-Host "üìù Example: Configure via curl"
            Write-Host ""
            Write-Host "curl -X POST $tunnelUrl/api/configure \"
            Write-Host "  -H 'Content-Type: application/json' \"
            Write-Host "  -d '{""rc1"":""YourCode"",""planet"":""Earth"",""device"":""312""}'"
            Write-Host ""
            Write-Host "=========================================="
            Write-Host ""
            
          } catch {
            Write-Host "Could not retrieve tunnel URL"
          }

      - name: Keep Running
        shell: pwsh
        run: |
          $duration = [int]"${{ github.event.inputs.duration }}"
          if ($duration -gt 360) { $duration = 360 }  # Max 6 hours
          if ($duration -lt 1) { $duration = 60 }     # Default 1 hour
          
          Write-Host "`n=========================================="
          Write-Host "üöÄ Backend is now running!"
          Write-Host "=========================================="
          Write-Host ""
          Write-Host "Duration: $duration minutes"
          Write-Host "Started: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
          Write-Host "Will stop: $((Get-Date).AddMinutes($duration).ToString('yyyy-MM-dd HH:mm:ss'))"
          Write-Host ""
          Write-Host "Monitoring status every 60 seconds..."
          Write-Host ""
          
          $endTime = (Get-Date).AddMinutes($duration)
          
          while ((Get-Date) -lt $endTime) {
            try {
              $status = Invoke-RestMethod -Uri "http://localhost:3000/api/status" -ErrorAction SilentlyContinue
              $remaining = [math]::Round((($endTime - (Get-Date)).TotalMinutes), 1)
              
              $connectedStatus = if ($status.connected) { "‚úÖ Connected" } else { "‚≠ï Disconnected" }
              $activeWS = @($status.websockets.PSObject.Properties | Where-Object { $_.Value -eq $true }).Count
              
              Write-Host "[$(Get-Date -Format 'HH:mm:ss')] $connectedStatus | Active WebSockets: $activeWS | Time remaining: $remaining min"
            } catch {
              Write-Host "[$(Get-Date -Format 'HH:mm:ss')] ‚ö†Ô∏è  Server status check failed"
            }
            Start-Sleep -Seconds 60
          }
          
          Write-Host "`n=========================================="
          Write-Host "‚è∞ Run duration completed. Shutting down..."
          Write-Host "=========================================="

      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          Write-Host "Cleaning up..."
          
          # Disconnect WebSockets
          try {
            Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/disconnect" -ContentType "application/json" -ErrorAction SilentlyContinue
            Write-Host "‚úÖ WebSockets disconnected"
          } catch {
            Write-Host "Disconnect request failed (server may already be stopped)"
          }
          
          Write-Host "Cleanup complete"
