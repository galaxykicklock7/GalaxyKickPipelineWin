name: BEST Headless Server with Cloudflare Tunnel

on:
  workflow_dispatch:
    inputs:
      rc1:
        description: 'Recovery Code 1'
        required: false
        type: string
      rc2:
        description: 'Recovery Code 2'
        required: false
        type: string
      rc3:
        description: 'Recovery Code 3'
        required: false
        type: string
      rc4:
        description: 'Recovery Code 4'
        required: false
        type: string
      kickrc:
        description: 'Kick Code'
        required: false
        type: string
      planet:
        description: 'Planet Name'
        required: false
        type: string
      device:
        description: 'Device Type (312=Android, 323=iOS, 352=Web)'
        required: false
        default: '312'
        type: string
      duration:
        description: 'Run duration in minutes (max 360 = 6 hours)'
        required: false
        default: '60'
        type: string

jobs:
  run-best-headless:
    runs-on: windows-latest
    timeout-minutes: 360  # Maximum 6 hours
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'

      - name: Install dependencies
        shell: pwsh
        run: |
          cd resources/app
          npm install

      - name: Setup Cloudflared
        shell: pwsh
        run: |
          Write-Host "Downloading cloudflared..."
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile "cloudflared.exe"
          Write-Host "Cloudflared downloaded successfully"

      - name: Start BEST in Headless Mode
        shell: pwsh
        env:
          HEADLESS: 'true'
          API_PORT: '3000'
        run: |
          Write-Host "Starting BEST in headless mode..."
          cd resources/app
          Start-Process -NoNewWindow -FilePath "npm" -ArgumentList "run", "headless-win"
          Write-Host "Waiting for API server to start..."
          Start-Sleep -Seconds 10

      - name: Start Cloudflare Tunnel
        shell: pwsh
        run: |
          Write-Host "Starting Cloudflare Tunnel..."
          Start-Process -NoNewWindow -FilePath ".\cloudflared.exe" -ArgumentList "tunnel", "--url", "http://localhost:3000"
          Start-Sleep -Seconds 5
          
          Write-Host "Fetching tunnel URL..."
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -ErrorAction SilentlyContinue
            if ($response) {
              Write-Host "Tunnel established!"
            }
          } catch {
            Write-Host "Using cloudflared tunnel (URL will be shown in logs)"
          }

      - name: Configure BEST via API
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        shell: pwsh
        run: |
          Write-Host "Configuring BEST..."
          
          $config = @{
            rc1 = "${{ github.event.inputs.rc1 }}"
            rc2 = "${{ github.event.inputs.rc2 }}"
            rc3 = "${{ github.event.inputs.rc3 }}"
            rc4 = "${{ github.event.inputs.rc4 }}"
            kickrc = "${{ github.event.inputs.kickrc }}"
            planet = "${{ github.event.inputs.planet }}"
            device = "${{ github.event.inputs.device }}"
          }
          
          $jsonConfig = $config | ConvertTo-Json
          
          Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/configure" -Body $jsonConfig -ContentType "application/json"
          Write-Host "Configuration applied"

      - name: Connect to Game
        if: ${{ github.event.inputs.rc1 != '' || github.event.inputs.rc2 != '' || github.event.inputs.rc3 != '' || github.event.inputs.rc4 != '' }}
        shell: pwsh
        run: |
          Write-Host "Connecting to game server..."
          Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/connect" -ContentType "application/json"
          Write-Host "Connection initiated"

      - name: Display Connection Info
        shell: pwsh
        run: |
          Write-Host "`n=========================================="
          Write-Host "BEST API Server is now running!"
          Write-Host "=========================================="
          Write-Host ""
          Write-Host "Local API URL: http://localhost:3000"
          Write-Host ""
          Write-Host "Check cloudflared logs above for the public tunnel URL"
          Write-Host "It will be something like: https://xxxxx.trycloudflare.com"
          Write-Host ""
          Write-Host "Available API Endpoints:"
          Write-Host "  GET  /api/health      - Health check"
          Write-Host "  GET  /api/status      - Get current status"
          Write-Host "  GET  /api/logs        - Get all logs"
          Write-Host "  POST /api/configure   - Update configuration"
          Write-Host "  POST /api/connect     - Connect all WebSockets"
          Write-Host "  POST /api/disconnect  - Disconnect all WebSockets"
          Write-Host "  POST /api/send        - Send command to specific WebSocket"
          Write-Host ""
          Write-Host "Example JSON request:"
          Write-Host @'
          {
            "rc1": "your_code_1",
            "rc2": "your_code_2",
            "planet": "YourPlanet",
            "device": "312"
          }
          '@
          Write-Host ""
          Write-Host "==========================================`n"

      - name: Keep Running
        shell: pwsh
        run: |
          $duration = [int]"${{ github.event.inputs.duration }}"
          if ($duration -gt 360) { $duration = 360 }  # Max 6 hours
          if ($duration -lt 1) { $duration = 60 }     # Default 1 hour
          
          Write-Host "Server will run for $duration minutes..."
          Write-Host "Monitor the logs above for the Cloudflare tunnel URL"
          Write-Host "You can send requests to that URL to control BEST"
          
          $endTime = (Get-Date).AddMinutes($duration)
          
          while ((Get-Date) -lt $endTime) {
            try {
              $status = Invoke-RestMethod -Uri "http://localhost:3000/api/status" -ErrorAction SilentlyContinue
              $remaining = [math]::Round((($endTime - (Get-Date)).TotalMinutes), 1)
              Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Status: Connected=$($status.connected) | Time remaining: $remaining minutes"
            } catch {
              Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Server status check failed"
            }
            Start-Sleep -Seconds 60
          }
          
          Write-Host "`nRun duration completed. Shutting down..."

      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          Write-Host "Disconnecting all WebSockets..."
          try {
            Invoke-RestMethod -Method POST -Uri "http://localhost:3000/api/disconnect" -ContentType "application/json" -ErrorAction SilentlyContinue
          } catch {
            Write-Host "Disconnect request failed (server may already be stopped)"
          }
          Write-Host "Cleanup complete"
